{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Data modeling and ontologies implementation in the BAM Data Store","text":"<p>The goal of this documentation page is to provide a place for the information presented during the BAM Data Store Days for the Group 2. This event took place from Wednesday, April 9, 2025, to Friday, April 11, 2025. The focus of Group 2 is to work with the BAM Masterdata definitions, improving them if possible and extending them when necessary, identifying commonalities amongst participants, and working together towards an higher-level ontology implementation for such definitions.</p>"},{"location":"#preparation","title":"Preparation","text":"<p>In order to be ready for this event, we ask the participants to prepare an example use-case of the workflows that they typically perform during their scientific activities. In this group, it is necessary to have a minimal knowledge of Python and Github. We list here the resources which will be used during the event:</p> <ul> <li>BAMresearch/bam-masterdata: The Github repository containing the main BAM Masterdata definitions as well as some important utility functions.</li> <li>BAMresearch/masterdata-template: A template Github repository to be used when the BAM Masterdata definitions need to be extended.</li> <li>BAMresearch/masterdata-generator: A cookiecutter Github repository used to generate the skeleton of the Masterdata templates.</li> <li>BAM Data Store Wiki: The BAM Data Store Wiki containing useful information about the software and project.</li> <li>Main BAM Data Store instance: The main instance of the BAM Data Store. Note this can only be accessed when in the BAM network.</li> <li>Testing playground instance: The testing instance used during the BAM Data Store Days. Note this can only be accessed when in the BAM network.</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>If you have further questions, please contact datastore@bam.de. You can also reach out to the organizers of Group 2: Carlos Madariaga and Jose Pizarro Blanco.</p>"},{"location":"block_1/","title":"Block I - Introduction to the BAM Data Store","text":"<p>This part of the Data Store Days consists of a slide presentation: Download here. (TODO: add link for slides) We also refer to the Data Store Wiki for all the definitions of the main concepts in openBIS and in the Data Store project.</p>"},{"location":"block_1/#bam-data-model-and-masterdata-definitions","title":"BAM Data Model and Masterdata definitions","text":"<p>OpenBIS and the data therein is organized following a folder-like structure space/project/collection/object_types/datasets. The object types and datasets are the main data structures used in openBIS. The object types represent tangible and intangible entities and their attached metainformation. The datasets can also contain metainformation and attached files. The data model in openBIS is defined by the object types and its assigned properties, plus the parent-child relationships created between the objects. The assigned properties have different datatypes: they can be strings, floats, etc., and they can also be controlled vocabularies. A controlled vocabulary is an enumeration of strings that the assigned property can take. </p> <p>We call Masterdata (or schema) to all the defined object types, property types, and vocabularies without the actual data populating the assigned properties and without the parent-child relationships. These parent-child relationships allows to connect object types hence representing the full workflow done during the scientific activity.</p> <p>For example, <code>Instrument</code> and <code>Sample</code> are object types with a set of assigned properties like <code>name</code>, <code>manufacturer</code>, <code>device_model_name</code>, or <code>physical_state</code>, to name a few. <code>physical_state</code> is a controlled vocabulary so it can only be defined as <code>\"solid\"</code>, <code>\"liquid\"</code>, and <code>\"gaseous\"</code>. Both object types can be connected via a parent-child relationship, representing perhaps a characterization measurement of an instrument over a synthesized sample.</p> <p>In openBIS, we also distinguish between the ELN and the Inventory components in order to differentiate between objects which exists in a laboratory and can be reused by different team members (Inventory objects) from the actual objects used during the scientific workflow (ELN objects). Despite this distinction, the data model can be defined using objects from both components, so the main concepts of the software apply indistinctly.</p>"},{"location":"block_1/#represent-your-research-workflow-in-the-data-store","title":"Represent your research workflow in the Data Store","text":"<p>In order to represent your workflow in the Data Store, you need to:</p> <ol> <li>Identify the tangible and intangible object types used in the workflow.</li> <li>Explore the currently defined object types and their assigned properties to check if any of them align with the object types that you need to represent your workflow.</li> <li>For those cases where you do not find an object type already defined, extend the current Masterdata (see Block II - BAM Masterdata).</li> <li>Once the Masterdata contains all the object types that you need, populate your schema with the actual data (see Block III - Representing workflows in the BAM Data Store).</li> </ol> <p>In this block, we will focus on the initial two points. For this example, we will assume that all the object types we need are already defined in the current BAM Masterdata so that we do not need to extend it.</p>"},{"location":"block_1/#identify-your-object-types","title":"Identify your object types","text":"<p>You can either use a piece of paper or the drawio document (TODO: add link) that we prepared in the Data Store team.</p> <p>We are going to construct a directed acyclic graph (DAG) representing the workflow in your research. As an example, let's consider we have:</p> <p>We can identify the elements in this workflow with the Inventory and the ELN components. Furthermore, we could identify them with already existing Masterdata and assign the corresponding properties to each object.</p> <p>The difference between both workflows is that the second one uses object types already defined in BAM Masterdata: <code>Chemical</code>, <code>Instrument</code>, <code>Experimental Step</code>, and <code>Sample</code>. Visit bam-masterdata in Github to explore the current Masterdata.</p> Improving the users experience <p>An important part of our efforts right now is to improve the experience of exploring the current BAM Masterdata. Our plan is to use WebVOWL or WebProt\u00e9g\u00e9 as a tool for visualizing the object types, their properties, and the inheritance relationships between them. See Block II - Collaborate and define generic entity types for more information.</p> Real case scenario <p>This example is actually too simplistic. In reality, the chances that the current BAM Masterdata does not have the object types and their assigned properties defined as you need are high. This situation also depends about how fine-grained you want to defined your workflow, and the requirements of your project. A good scientific practice is to represent your workflows as minimal as possible while keeping reproducibility maximize. And as in any data modelling project, we aim to define object types which are generic enough for any field of Materials Science Engineering to use the definitions and extend them for specific use-cases.</p>"},{"location":"block_2/","title":"Block II - BAM Masterdata","text":"<p>In Block I - Introduction to the BAM Data Store, we saw what is the BAM Data Store structure, and how it is based on two main ingredients to populate the data model with actual data: the Masterdata definitions (composed of object types, property types, and vocabularies) + the parent-child relationships.</p> <p>At BAM, we already have defined Masterdata, see bam-masterdata. In some cases, these Masterdata definitions are not specific enough for your use-case. For those cases, we will show you here how to create your own Github repository to define and work extending current BAM Masterdata. If you are interested about working collaboratively on the generic BAM Masterdata definitions, you can contact us and request access to our (WebProt\u00e9g\u00e9) project.</p>"},{"location":"block_2/#bam-masterdata","title":"<code>bam-masterdata</code>","text":"<p><code>bam-masterdata</code> is a Python package with a set of API functions used to work and manipulate openBIS Masterdata. Our goal is to be able to define Masterdata in the most common formats (Excel, Python, and RDF/XML) while parsing back and forth between them. At BAM, the generic Masterdata definitions are defined in the datamodel folder, and they are used as the basis to extend the current BAM Masterdata. The package has some utilities to check the consistency of the defined Masterdata.</p> <p>This package uses a CLI for using the API functions. For example, if you defined your Masterdata in Excel, you can easily transform this into Python by doing (in a terminal and with <code>bam-masterdata</code> installed as a pip package): <pre><code>bam_masterdata fill_masterdata --excel-file=&lt;the-path-to-your-Excel-file&gt;\n</code></pre></p> <p>As for any CLI, you can read more about each specific option by adding <code>--help</code> at the end of any command. <pre><code>Usage: bam_masterdata [OPTIONS] COMMAND [ARGS]...\n\n  Entry point to run `bam_masterdata` CLI\n  commands.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  checker          Checks the files specified...\n  export_to_excel  Export entities to an...\n  export_to_json   Export entities to JSON...\n  export_to_rdf    Export entities to a...\n  fill_masterdata  Fill the masterdata from...\n</code></pre></p> <p>In Excel, we have manually defined inheritance between object types for paving the way to implement ontologies in the platform. Such inheritance is specified for each object type by defining the <code>code</code> of such object as a path of codes (starting from the parent) separated by dots. For example, if we have to define <code>SuperProcessedSample</code> as inheriting from <code>ProcessedSample</code>, which at the same time is inheriting from <code>Sample</code>, then the <code>code</code> for all these object types will be: <code>SAMPLE</code>, <code>SAMPLE.PROCESSED_SAMPLE</code>, and <code>SAMPLE.PROCESSED_SAMPLE.SUPER_PROCESSED_SAMPLE</code>.</p> bam-masterdata documentation <p>As of April 2025, the <code>bam-masterdata</code> package is in a alpha testing phase. Unfortunately, we have not written any documentation for all the API of the package. This is partly because we want feedback from potential users and collaborators. </p>"},{"location":"block_2/#create-and-define-your-own-masterdata","title":"Create and define your own Masterdata","text":""},{"location":"block_2/#create-a-new-github-repository","title":"Create a new Github repository","text":"<p>Go to BAMresearch/masterdata-template and click on the top-right button, Use this template &gt; Create a new repository.</p> <p>This will take you to another page where you can decide where to host the new Github repository and some other settings. We recommend starting the name of your repository with <code>masterdata-</code>, so it can be easily cataloged.</p> <p>After creating your new repository, you can either clone it locally (we will follow this approach) or open it in Github Codespace:</p> <p>You also need to install <code>cruft</code>.</p> <p>After cloning your repository, move into it: <pre><code>git clone &lt;path-to-your-repository&gt;\ncd &lt;path-to-your-repository&gt;\n</code></pre> And use <code>cruft</code> with the following command to create the structure of the new Masterdata project: <pre><code>cruft create https://github.com/BAMresearch/masterdata-generator\n</code></pre></p> <p>This will prompt you with some questions to be filled in: <pre><code>  [1/9] author (Erika Mustermann): \n  [2/9] email (erika.mustermann@bam.de): \n  [3/9] Github organization or profile name (BAMResearch): \n  [4/9] project_name (masterdata-example): \n  [5/9] The name of the folder src/&lt;module_name&gt;, default is the \n&lt;project_name&gt; separated with underscores (masterdata_example): \n  [6/9] short_description (A short description for the masterdata project.): \n  [7/9] include_python_masterdata [y/n] (y): \n  [8/9] include_excel_masterdata [y/n] (y): \n  [9/9] include_rdfxml_masterdata [y/n] (y): \n</code></pre></p> <p>Warning</p> <p>Not filling anything on the questions above will result on choosing the default. The default value for each question is defined in between parenthesis next to the question.</p> <p>The files generated by <code>cruft</code> are created under <code>&lt;your-repository-name&gt;/&lt;project-name&gt;</code>. To move all the structure one level up, from the repository local location run: <pre><code>sh &lt;project-name&gt;/move_generated_files.sh\n</code></pre></p> <p>After filling the questionnaire and running the <code>move_generated_files.sh</code> script, you will have a new repository with: <pre><code>masterdata-&lt;name&gt;/\n\u251c\u2500\u2500 LICENSE (MIT)\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 masterdata-&lt;name&gt;/\n#        if Python is selected as an option\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 object_types.py\n\u2502       \u251c\u2500\u2500 vocabulary_types.py\n#       if Excel is selected as an option\n\u2502       \u251c\u2500\u2500 masterdata.xlsx\n#       if RDF/XML is selected as an option\n\u2502       \u2514\u2500\u2500 masterdata.owl\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test.py\n</code></pre></p> <p>If you are using Python, you can install the package and its dependencies by creating a virtual environment (either with <code>conda</code> or <code>venv</code>) and running: <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install --upgrade pip\npip install uv\nuv pip install -e '.[dev]'\n</code></pre></p> <p>The newly created Github repository is ready for packaging and create releases if you want. It has a Github workflow defined (amongst them there is the <code>checker</code> action). If you choose to keep your repository private, you will need to setup your own runners or run locally each action everytime you push changes to the repository.</p>"},{"location":"block_2/#define-masterdata","title":"Define Masterdata","text":"<p>Once you have the skeleton of the Masterdata repository, you can define new classes in the corresponding file under <code>src/&lt;module-name&gt;/</code>. In case of Python, these are different modules for Object Types and Vocabularies. For Excel or RDF/XML, this is a single file named <code>masterdata.xlsx</code>/<code>masterdata.owl</code>, respectively. In all the cases, a dummy entity called <code>ExampleObjectType</code> is created to serve as an example.</p> <p>Depending on the format chosen (Excel, Python, RDF/XML), you can follow the example to create new object types and vocabularies. A full list of datatypes for the assigned properties can be found in the openBIS documentation. We also defined in our Wiki page the process of how to define Masterdata in Excel.</p>"},{"location":"block_2/#check-consistency","title":"Check consistency","text":"<p>One of the main API functions of <code>bam-masterdata</code> is the <code>checker</code>. This functionality is integrated in the Github workflow actions of the repository created before. Its main role is to check that the defined object types, property types, and vocabularies are consistent and there are no conflicts in the repository itself but also with respect to the generic types defined in <code>bam-masterdata</code>. It also validates the Masterdata definitions format and ensures that it is compliant with the openBIS database structure.</p> <p>We also deployed a website to check the Masterdata definitions in an Excel. You can visit the Checker website and upload an Excel file. Note that this website is a bit outdated and will soon be improved with the current <code>check</code> API functionality.</p>"},{"location":"block_2/#collaborate-and-define-generic-entity-types","title":"Collaborate and define generic entity types","text":"<p>The current Masterdata definitions in the BAM Data Store can be better visualized in WebProt\u00e9g\u00e9. Prot\u00e9g\u00e9 is a software used to work and develop ontologies, but our aim is simpler: we want a tool to visualize the current Masterdata definitions, the relationships between object types, and the defined property types. This software allows us to export the Masterdata into a ontology-friendly format like owl, rdf/xml, or ttl. It also interfaces easily with Github pages and WebVOWL.</p> <p>If you are interested about working collaboratively on the generic BAM Masterdata definitions or on visualizing the current Masterdata definitions, you can contact us and request access to our WebProt\u00e9g\u00e9 project.</p>"},{"location":"block_3/","title":"Block III - Representing workflows in the BAM Data Store","text":"<p>Warning</p> <p>This page is still under construction.</p>"}]}